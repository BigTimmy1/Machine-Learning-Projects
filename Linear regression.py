# -*- coding: utf-8 -*-
"""CoAI1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ASbOPqrc7N5kXOKSZddOLDiXFiM0zfks
"""

#Importing necessary libraries.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Setting seaborn for better visualization aesthetics
sns.set()

# Importing libraries for regression models and evaluation
from sklearn.linear_model import LinearRegression, Ridge, Lasso
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import StandardScaler
from statsmodels.stats.outliers_influence import variance_inflation_factor

data = pd.read_csv("houseprice_data.csv")

data.describe()

# Initial data exploration
print("First few rows of the dataset:")
data.head()

# Check for missing values
data.isnull().sum()

# Visualizing data distributions
data.hist(bins=30, figsize=(20, 15))
plt.suptitle('Distribution of Continuous Variables')
plt.xlabel('Features')
plt.ylabel('Frequency')
plt.show()

# Correlation matrix and heatmap
correlation_matrix = data.corr()
plt.figure(figsize=(15, 7))
sns.heatmap(correlation_matrix, annot=True, cmap="CMRmap_r")
plt.title('Correlation Matrix Heatmap')
plt.show()

# Adding 'house_age' feature
data['house_age'] = 2024 - data['yr_built']  # Update with the current year

# Adding binary feature 'is_renovated' (1 if renovated, 0 if not)
data['is_renovated'] = data['yr_renovated'].apply(lambda x: 1 if x > 0 else 0)

# Categorizing year built into bins
bin_edges = [1900, 1950, 2000, 2015]
bin_labels = ['1900-1950', '1950-2000', '2000-2015']
data['year_built_category'] = pd.cut(data['yr_built'], bins=bin_edges, labels=bin_labels, right=False)

data.head(10)

# Price by year built category visualization
plt.figure(figsize=(10, 6))
sns.barplot(x='year_built_category', y='price', data=data, ci=None)
plt.title('Price vs Year Category')
plt.xlabel('Year Built Category')
plt.ylabel('Price')
plt.show()

# Removing highly correlated features using correlation and VIF
Xfeat = data.drop(['price', 'year_built_category'], axis=1)

# Drop features with high VIF or correlation
Xfeat = Xfeat.drop(['sqft_living15', 'sqft_lot15'], axis=1)

# Splitting the data into training and test sets
X = Xfeat
y = data['price']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=40)

# Scaling the data
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Function to evaluate models
def evaluate_model(model, X_test, y_test, predictions):
    mse = mean_squared_error(y_test, predictions)
    r2 = r2_score(y_test, predictions)
    mae = mean_absolute_error(y_test, predictions)
    print(f'\nModel Evaluation for {model}:')
    print(f'Mean Squared Error (MSE): {mse}')
    print(f'R-squared: {r2}')
    print(f'Mean Absolute Error (MAE): {mae}')
    return mse, r2, mae

# Linear Regression
linear_model = LinearRegression()
linear_model.fit(X_train_scaled, y_train)
linear_predictions = linear_model.predict(X_test_scaled)
evaluate_model('Linear Regression', X_test, y_test, linear_predictions)

linear_model.coef_

linear_model.intercept_

# Scatter plot for Actual vs Predicted prices for each model
def plot_actual_vs_predicted(predictions, y_test, model_name):
    slope, intercept = np.polyfit(predictions, y_test, 1)
    line = slope * predictions + intercept

    plt.figure(figsize=(10, 6))
    plt.scatter(predictions, y_test, color='skyblue', label='Actual vs Predicted')
    plt.plot(predictions, line, color='blue', label='Perfect Prediction Line')
    plt.title(f'{model_name} - Actual vs Predicted Prices')
    plt.xlabel('Predicted Prices')
    plt.ylabel('Actual Prices')
    plt.legend()
    plt.show()

# Plot for each model
plot_actual_vs_predicted(linear_predictions, y_test, 'Linear Regression')

# Coefficient of determination for the model on test data
print('Coefficient of determination: %.2f' % r2_score(y_test, linear_model.predict(X_test_scaled)))

# Visualize the initial dataset in 3D with "sqft_living" and "bedrooms" features
fig1 = plt.figure(figsize=(8, 6))
ax1 = fig1.add_subplot(111, projection='3d')
ax1.scatter(X['sqft_living'], X['bedrooms'], y, color='blue')
ax1.azim = -60
ax1.dist = 10
ax1.elev = 20
ax1.set_xlim(X['sqft_living'].min(), X['sqft_living'].max())
ax1.set_ylim(X['bedrooms'].min(), X['bedrooms'].max())
ax1.set_zlim(y.min(), y.max())
ax1.set_title('Initial Dataset')
ax1.set_xlabel('Living Area (sqft)')
ax1.set_ylabel('Number of Bedrooms')
ax1.set_zlabel('Price ($)')
fig1.tight_layout(pad=-2.0)
fig1.show

# Visualize the training set results in 3D with the plane
fig2 = plt.figure(figsize=(8, 6))
ax2 = fig2.add_subplot(111, projection='3d')
# Plot the training data
ax2.scatter(X_train['sqft_living'], X_train['bedrooms'], y_train, color='blue')

# Generate the plane that represents the model
X1, X2 = np.meshgrid(
    np.linspace(X['sqft_living'].min(), X['sqft_living'].max(), 10),
    np.linspace(X['bedrooms'].min(), X['bedrooms'].max(), 10)
)
Z = linear_model.coef_[0] * X1 + linear_model.coef_[1] * X2 + linear_model.intercept_
ax2.plot_surface(X1, X2, Z, alpha=0.5, color='red')
ax2.azim = -60
ax2.dist = 10
ax2.elev = 20
ax2.set_xlim(X['sqft_living'].min(), X['sqft_living'].max())
ax2.set_ylim(X['bedrooms'].min(), X['bedrooms'].max())
ax2.set_zlim(y.min(), y.max())
ax2.set_title('Training Set')
ax2.set_xlabel('Living Area (sqft)')
ax2.set_ylabel('Number of Bedrooms')
ax2.set_zlabel('Price ($)')
fig2.tight_layout(pad=-2.0)
fig2.show

# Visualize the test set results in 3D with the plane
fig3 = plt.figure(figsize=(8, 6))
ax3 = fig3.add_subplot(111, projection='3d')
# Plot the test data
ax3.scatter(X_test['sqft_living'], X_test['bedrooms'], y_test, color='blue')

# Plot the plane representing the model's prediction
ax3.plot_surface(X1, X2, Z, alpha=0.5, color='red')
ax3.azim = -60
ax3.dist = 10
ax3.elev = 20
ax3.set_xlim(X['sqft_living'].min(), X['sqft_living'].max())
ax3.set_ylim(X['bedrooms'].min(), X['bedrooms'].max())
ax3.set_zlim(y.min(), y.max())
ax3.set_title('Test Set')
ax3.set_xlabel('Living Area (sqft)')
ax3.set_ylabel('Number of Bedrooms')
ax3.set_zlabel('Price ($)')
fig3.tight_layout(pad=-2.0)
fig3.show()